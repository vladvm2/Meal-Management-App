import { Action, ActionCreator, Creator } from '@ngrx/store';
import { Observable, OperatorFunction, Operator } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare class Actions<V = Action> extends Observable<V> {
    constructor(source?: Observable<V>);
    lift<R>(operator: Operator<V, R>): Observable<R>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Actions<any>>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Actions<any>>;
}
declare type ActionExtractor<T extends string | AC, AC extends ActionCreator<string, Creator>, E> = T extends string ? E : ReturnType<Extract<T, AC>>;
/**
 * 'ofType' filters an Observable of Actions into an observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 */
export declare function ofType<AC extends ActionCreator<string, Creator>[], U extends Action = Action, V = ReturnType<AC[number]>>(...allowedTypes: AC): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, U extends Action = Action, V = T1 extends string ? E : ReturnType<Extract<T1, AC>>>(t1: T1): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2, AC, E>>(t1: T1, t2: T2): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3, AC, E>>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3 | T4;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3 | T4 | T5;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, T5 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;
/**
 * Fallback for more than 5 arguments.
 * There is no inference, so the return type is the same as the input -
 * Observable<Action>.
 *
 * We provide a type parameter, even though TS will not infer it from the
 * arguments, to preserve backwards compatibility with old versions of ngrx.
 */
export declare function ofType<V extends Action>(...allowedTypes: Array<string | ActionCreator<string, Creator>>): OperatorFunction<Action, V>;
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5kLnRzIiwic291cmNlcyI6WyJhY3Rpb25zLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUVBOzs7OztBQUdBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBBY3Rpb25DcmVhdG9yLCBDcmVhdG9yIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT3BlcmF0b3JGdW5jdGlvbiwgT3BlcmF0b3IgfSBmcm9tICdyeGpzJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFjdGlvbnM8ViA9IEFjdGlvbj4gZXh0ZW5kcyBPYnNlcnZhYmxlPFY+IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBPYnNlcnZhYmxlPFY+KTtcbiAgICBsaWZ0PFI+KG9wZXJhdG9yOiBPcGVyYXRvcjxWLCBSPik6IE9ic2VydmFibGU8Uj47XG59XG5kZWNsYXJlIHR5cGUgQWN0aW9uRXh0cmFjdG9yPFQgZXh0ZW5kcyBzdHJpbmcgfCBBQywgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sIEU+ID0gVCBleHRlbmRzIHN0cmluZyA/IEUgOiBSZXR1cm5UeXBlPEV4dHJhY3Q8VCwgQUM+Pjtcbi8qKlxuICogJ29mVHlwZScgZmlsdGVycyBhbiBPYnNlcnZhYmxlIG9mIEFjdGlvbnMgaW50byBhbiBvYnNlcnZhYmxlIG9mIHRoZSBhY3Rpb25zXG4gKiB3aG9zZSB0eXBlIHN0cmluZ3MgYXJlIHBhc3NlZCB0byBpdC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYGFjdGlvbnNgIGhhcyB0eXBlIGBBY3Rpb25zPEFkZGl0aW9uQWN0aW9ufFN1YnN0cmFjdGlvbkFjdGlvbj5gLCBhbmRcbiAqIHRoZSB0eXBlIG9mIHRoZSBgQWRkaXRpb25gIGFjdGlvbiBpcyBgYWRkYCwgdGhlblxuICogYGFjdGlvbnMucGlwZShvZlR5cGUoJ2FkZCcpKWAgcmV0dXJucyBhbiBgT2JzZXJ2YWJsZTxBZGRpdGlvbkFjdGlvbj5gLlxuICpcbiAqIFByb3Blcmx5IHR5cGluZyB0aGlzIGZ1bmN0aW9uIGlzIGhhcmQgYW5kIHJlcXVpcmVzIHNvbWUgYWR2YW5jZWQgVFMgdHJpY2tzXG4gKiBiZWxvdy5cbiAqXG4gKiBUeXBlIG5hcnJvd2luZyBhdXRvbWF0aWNhbGx5IHdvcmtzLCBhcyBsb25nIGFzIHlvdXIgYGFjdGlvbnNgIG9iamVjdFxuICogc3RhcnRzIHdpdGggYSBgQWN0aW9uczxTb21lVW5pb25PZkFjdGlvbnM+YCBpbnN0ZWFkIG9mIGdlbmVyaWMgYEFjdGlvbnNgLlxuICpcbiAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2hlbiBvbmUgcGFzc2VzIGEgc2luZ2xlIHR5cGUgYXJndW1lbnRcbiAqIGBvZlR5cGU8VD4oJ3NvbWV0aGluZycpYCB0aGUgcmVzdWx0IGlzIGFuIGBPYnNlcnZhYmxlPFQ+YC4gTm90ZSwgdGhhdCBgVGBcbiAqIGNvbXBsZXRlbHkgb3ZlcnJpZGVzIGFueSBwb3NzaWJsZSBpbmZlcmVuY2UgZnJvbSAnc29tZXRoaW5nJy5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCBmb3IgdW5rbm93biAnYWN0aW9uczogQWN0aW9ucycgdGhlc2UgdHlwZXMgd2lsbCBwcm9kdWNlXG4gKiAnT2JzZXJ2YWJsZTxuZXZlcj4nLiBJbiBzdWNoIGNhc2VzIG9uZSBoYXMgdG8gbWFudWFsbHkgc2V0IHRoZSBnZW5lcmljIHR5cGVcbiAqIGxpa2UgYGFjdGlvbnMub2ZUeXBlPEFkZGl0aW9uQWN0aW9uPignYWRkJylgLlxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBvZlR5cGU8QUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj5bXSwgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbiwgViA9IFJldHVyblR5cGU8QUNbbnVtYmVyXT4+KC4uLmFsbG93ZWRUeXBlczogQUMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gb2ZUeXBlPEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHtcbiAgICB0eXBlOiBUMTtcbn0+LCBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPiwgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbiwgViA9IFQxIGV4dGVuZHMgc3RyaW5nID8gRSA6IFJldHVyblR5cGU8RXh0cmFjdDxUMSwgQUM+Pj4odDE6IFQxKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxFIGV4dGVuZHMgRXh0cmFjdDxVLCB7XG4gICAgdHlwZTogVDEgfCBUMjtcbn0+LCBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPiwgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbiwgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyLCBBQywgRT4+KHQxOiBUMSwgdDI6IFQyKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxFIGV4dGVuZHMgRXh0cmFjdDxVLCB7XG4gICAgdHlwZTogVDEgfCBUMiB8IFQzO1xufT4sIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LCBUMSBleHRlbmRzIHN0cmluZyB8IEFDLCBUMiBleHRlbmRzIHN0cmluZyB8IEFDLCBUMyBleHRlbmRzIHN0cmluZyB8IEFDLCBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLCBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIgfCBUMywgQUMsIEU+Pih0MTogVDEsIHQyOiBUMiwgdDM6IFQzKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxFIGV4dGVuZHMgRXh0cmFjdDxVLCB7XG4gICAgdHlwZTogVDEgfCBUMiB8IFQzIHwgVDQ7XG59PiwgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFQzIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFQ0IGV4dGVuZHMgc3RyaW5nIHwgQUMsIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiB8IFQzIHwgVDQsIEFDLCBFPj4odDE6IFQxLCB0MjogVDIsIHQzOiBUMywgdDQ6IFQ0KTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxFIGV4dGVuZHMgRXh0cmFjdDxVLCB7XG4gICAgdHlwZTogVDEgfCBUMiB8IFQzIHwgVDQgfCBUNTtcbn0+LCBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPiwgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDMgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDQgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDUgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbiwgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1LCBBQywgRT4+KHQxOiBUMSwgdDI6IFQyLCB0MzogVDMsIHQ0OiBUNCwgdDU6IFQ1KTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbi8qKlxuICogRmFsbGJhY2sgZm9yIG1vcmUgdGhhbiA1IGFyZ3VtZW50cy5cbiAqIFRoZXJlIGlzIG5vIGluZmVyZW5jZSwgc28gdGhlIHJldHVybiB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSBpbnB1dCAtXG4gKiBPYnNlcnZhYmxlPEFjdGlvbj4uXG4gKlxuICogV2UgcHJvdmlkZSBhIHR5cGUgcGFyYW1ldGVyLCBldmVuIHRob3VnaCBUUyB3aWxsIG5vdCBpbmZlciBpdCBmcm9tIHRoZVxuICogYXJndW1lbnRzLCB0byBwcmVzZXJ2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBuZ3J4LlxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBvZlR5cGU8ViBleHRlbmRzIEFjdGlvbj4oLi4uYWxsb3dlZFR5cGVzOiBBcnJheTxzdHJpbmcgfCBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4+KTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIFY+O1xuZXhwb3J0IHt9O1xuIl19